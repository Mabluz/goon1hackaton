#!/bin/bash

# Verifies that the occ script was generated by the currently running version of occam
# Abort with error message if not
function checkOccamVersion {
  local GENERATED_WITH_OCCAM_VERION="unversioned"
  local ACTUAL_OCCAM_VERSION=`curl -s -X GET --header 'Accept: text/plain' "$API/scripts/occamVersion"`
  if [ x"$GENERATED_WITH_OCCAM_VERION" != x"$ACTUAL_OCCAM_VERSION" ]; then
    echo "OCC-script outdated! Please run init.sh again!"
    exit -1;
  fi
}

# Determines environment (test or prod) based on current directory
# Returns result in var given by $1
function getEnv {
  local RET="$1"

  local GIT_ROOT=`git rev-parse --show-toplevel | sed -e "s/^\([a-zA-Z]\)\:/\/\1/g" | sed -e "s/^\/C/\/c/g"`
  if [ $? != 0 ]; then
    echo "Not inside git sandbox"
    exit 1;
  fi
  local p=`pwd`
  while [ "$GIT_ROOT" != "$p" ]; do
     if [[ "$p" != *"$GIT_ROOT"* ]]; then
       echo "Unexpected error: dir $p does not start with $GIT_ROOT"
       exit 1
     fi
     if [[ "$p" != *"/openshift/"* ]]; then
       echo "Unexpected error: dir $p does not contain an openshift folder"
       exit 1
     fi
     if [[ "$p" == *"/prod" ]]; then
       eval "$1='prod'"
       return;
     fi
     if [[ "$p" == *"/test" ]]; then
       eval "$1='test'"
       return;
     fi
     p=`dirname "$p"`;
  done
  echo "Unexpected error: Unable to determine environment"
  exit -1
}

# Verifies that the environment given by our current working directory matches the environment given by the used occam instance
function verifyEnvAgainsOccamEnv {
  getEnv ENV_BY_PATH
  ENV_BY_OCC_INSTANCE="prod"
  if [ "x$ENV_BY_OCC_INSTANCE" != "x" ]; then
    if [ "x$ENV_BY_OCC_INSTANCE" != "x$ENV_BY_PATH" ]; then
      echo "You are using the wrong occam instance."
      echo "The current path indicates that environment is $ENV_BY_PATH"
      echo "The occam instance used is for environment $ENV_BY_OCC_INSTANCE"
      echo "Please update init.sh with correct hostname for environment '$ENV_BY_PATH', and run it again."
      echo
      echo "Should look something like this: "
      echo
      echo '#!/bin/bash'
      echo
      echo 'eval "`curl -s http://<occam hostname for '$ENV_BY_PATH'>/dchub/occam/api/scripts/downloadScriptsScript`"'
      exit -1;
    fi
  fi
}

# Returns OCP host based on ENV given by $1 ('test' or 'prod')
# Returns result in var given by $2
function getOCPHost {
  local ENV="$1"
  local RET="$2"
  if [ "x$ENV" = "xtest" ]; then
    eval "$RET='test-dchub.corp.telenor.no'"
    return
  elif [ "x$ENV" = "xprod" ]; then
    eval "$RET='dchub.corp.telenor.no'"
    return
  else
    echo "Parent directory should be named 'test' or 'prod'"
    exit -1
  fi
}

function ocCom {
  [ ! -z "$verbose" ] && set -x > /dev/null
  oc $@
  local RET=$?
  { set +x; } 2>/dev/null
  return $RET
}

function validateSpec {
  local VALIDATIONREPORT=`curl -s -X POST --header 'Content-Type: text/plain' --header "Accept: text/plain" "$API/spec/validationReport" -d "\`cat spec.json\`"`
  if [ ! -z "$VALIDATIONREPORT" ]; then
    echo "Validation failed:"
    echo "$VALIDATIONREPORT"

    local ERRORS=`echo "$VALIDATIONREPORT" | grep -v Warning\:`

    if [ ! -z "$ERRORS" ]; then
      exit -1
    fi
  fi
}

function checkForAndReportError {
  if [ $? -ne 0 ]; then
    echo "Failed to generate $1, please check validation report"
  fi
}

function generateOpenshiftObject {
    local TYPE=$1
    mkdir -p .openshift-objects
    rm -f .openshift-objects/$TYPE.json

    local RESPONSE=$(curl \
        -s \
        -X POST \
        --header 'Content-Type: application/json' \
        --header 'Accept: application/json' \
        --header "ocp_token: $OCP_TOKEN" \
        -d "$SPEC" \
        --write-out "HTTPSTATUS:%{http_code}" \
        "$API/generator/$TYPE" \
        -o .openshift-objects/$TYPE.json)

    local BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
    local STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
    exitIfFailed "$STATUS" "$BODY"
}

function exitIfFailed {
  local STATUS=$1
  local BODY=$2
  if [ ! $STATUS -eq 200  ]; then
    echo "Operation failed: $BODY"
    exit 1
  fi
}

function updateObjects {
  local APIURI=$1
  local OBJFILE=$2

  if [ -z "$dryRun" ]; then
    local RESPONSE=$(curl -s -w "\n" -X POST -H "ocp_token: $OCP_TOKEN" -H "Content-Type: application/json" -H "Accepts: text/plain" --write-out "HTTPSTATUS:%{http_code}" "$APIURI" -d "`cat .openshift-objects/$OBJFILE`")
    local BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
    local STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
    exitIfFailed "$STATUS" "$BODY"
  else
    echo "SKIPPED! Since option -d (dry-run) is set."
  fi

}

function reinstallBuild {
  echo "Installing imagestream(s)"
  generateOpenshiftObject is
  updateObjects "$API/ocpobject/$ENV/imagestreams/" "is.json"

  CI_TYPE=$(cat spec.json | grep "ciType")
  if [ ! -z "${CI_TYPE}" ]; then
    echo "Starting Jenkins build..."
    curl https://occam-ci.test-dc.corp.telenor.no/api/v1/ci/job/build
    exit 0
  fi

  # Check if build qualifies for Jenkins Pipeline
  BUILD_PARENT=$(cat spec.json | grep "/dchub/build-spec/java-gradle-jenkins-pipeline.json\|/dchub/build-spec/node-11.1-alpine-jenkins-pipeline.json\|/dchub/build-spec/base-image-jenkins-pipeline.json")
  if [ ! -z "${BUILD_PARENT}" ]; then
    echo "Installing jenkinsfile(s)"

    if [ -z "$dryRun" ]; then
        generateOpenshiftObject jf
        updateObjects "$API/ocpobject/$ENV/jenkinsfiles/" "jf.json"
        APP_NAME=$(cat spec.json | grep -E \"name\" | head -1 | sed 's/[[:space:]\",]*//g' | sed 's/name://g')
        echo "Jenkins pipeline build started: https://jenkins.test-dc.corp.telenor.no/job/${APP_NAME}"
    else
        echo "SKIPPED! Since option -d (dry-run) is set."
    fi

  else
    echo "Installing build-configuration(s)"
    generateOpenshiftObject bc
    updateObjects "$API/ocpobject/$ENV/buildconfigs/" "bc.json"
  fi

}

function reinstallDeployment {
  echo "Installing service account(s)"
  generateOpenshiftObject sa
  updateObjects "$API/ocpobject/$ENV/serviceaccounts/" "sa.json"

  echo "Installing deployment-configuration(s)"
  generateOpenshiftObject dc
  updateObjects "$API/ocpobject/$ENV/deploymentconfigs/" "dc.json"

  echo "Installing service(s)"
  generateOpenshiftObject svc
  updateObjects "$API/ocpobject/$ENV/services/" "svc.json"

  echo "Installing route(s)"
  generateOpenshiftObject route
  updateObjects "$API/ocpobject/$ENV/routes/" "route.json"

  echo "Installing autoscalers(s)"
  generateOpenshiftObject autoscaler
  updateObjects "$API/ocpobject/$ENV/autoscalers/" "autoscaler.json"

  echo "Installing appdoc(s)"
  generateOpenshiftObject appdoc
  updateObjects "$API/ocpobject/$ENV/appdocs/" "appdoc.json"
}

function reinstallConfigMaps {
  eval "`curl -s -X POST --header 'Content-Type: application/json' "$API/scripts/generateConfigMaps" -d "$SPEC"`"

  for cm in .openshift-objects/cm/configmap*.json
  do
    if [ -z "$dryRun" ]; then
      local RESPONSE=$(curl  -s -w "\n" -X POST -H "ocp_token: $OCP_TOKEN" -H "namespace: $DEPLOYMENT_PROJECT" -H "Content-Type: application/json" -H "Accepts: text/plain" --write-out "HTTPSTATUS:%{http_code}" "$API/ocpobject/$ENV/configmaps/" -d @$cm)
      local BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')
      local STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
      exitIfFailed "$STATUS" "$BODY"
      echo $BODY
    else
      echo "SKIPPED! Since option -d (dry-run) is set."
    fi
  done
}

function startBuild {
    ## First cut on functionality to start build, doing it without changing the Occam server side/api
    ## Makes a lot of assumptions about structure of spec and generated BC, which should probaly be fixed, but which would require extending server side API

    # Ensure local objects are in sync with spec.json
    generateOpenshiftObject bc

    bcname=$(cat .openshift-objects/bc.json | grep -E \"name\" | head -1 | sed 's/[[:space:]\",]*//g' | sed 's/name://g')
    bcnamespace=$(cat .openshift-objects/bc.json | grep -E \"namespace\" | head -1 | sed 's/[[:space:]\",]*//g' | sed 's/namespace://g')

    if [ -z "$bcnamespace" ]; then
        echo "Could not find namespace for buildconfig ($bcnamespace)"
        exit 1
    fi

    echo Checking for build config \"$bcname\" in project \"$bcnamespace\"..

    bcfound=$(oc -n $bcnamespace get bc $bcname -o=jsonpath='{.metadata.name}')
    if [ "$bcname" = "$bcfound" ]; then
        echo "Starting build and following progress. Use Ctrl+C to stop following progress.."
        oc -n $bcnamespace start-build -F $bcname
    else
        echo Could not find name of build config. Try regenerating build config using 'occ bld'..
    fi
}

function login {
  if [ x"prod" == x"$ENV" ]; then
    echo "**********************"
    echo "*                    *"
    echo "*  PRODUCTION ENV !  *"
    echo "*                    *"
    echo "*    Be careful !    *"
    echo "*                    *"
    echo "**********************"
    echo
  fi
  echo "Logging in to \"$ENV\" at $OCP_HOST"
  echo

  if [ -z "$OPENSHIFT_USER" ]; then
    echo "HINT: Set environment variable OPENSHIFT_USER with correct username to simplify login"
    echo
    echo "Enter username"
    read OPENSHIFT_USER
  else
    echo "Username is $OPENSHIFT_USER"
  fi
  echo "Enter password for $OPENSHIFT_USER"
  read -s OPENSHIFT_PW

  oc login -u "$OPENSHIFT_USER" -p "$OPENSHIFT_PW" https://$OCP_HOST:8443 1>/dev/null
  if [ $? != 0 ]; then
    echo "Failed to log into \"$OCP_HOST\". ABORTING!"
    exit -1
  fi
}

function reloginIfNeccessary {
  local LOGGED_IN_AT=`oc project 2>&1 | grep "Using project" | sed -e "s/.* on server \"https\:\/\/\(.*\)\:8443.*/\1/g"`
  if [ x"$LOGGED_IN_AT" == x"$OCP_HOST" ]; then
    echo "We are logged in at the correct host already, proceeding..."
  elif [ x"$LOGGED_IN_AT" == x ]; then
    oc logout > /dev/null 2>&1  # Do a logout just to be sure, expected to fail.
    login
  else
    echo "Logged in at incorrect host: $LOGGED_IN_AT, logging out"
    oc logout
    if [ $? != 0 ]; then
      echo "Failed to log out of \"$LOGGED_IN_AT\", aborting to ensure not doing anything against wrong environment!"
      exit -1
    fi
    login
  fi
}

function promoteToTest {
  echo "Tagging $BUILD_PROJECT/$APP_IMAGESTREAM:$DEPLOYMENT_TAG -->  $BUILD_PROJECT/$APP_IMAGESTREAM:$BUILD_TAG"
  if [ -z "$dryRun" ]; then
    ocCom tag $BUILD_PROJECT/$APP_IMAGESTREAM:$BUILD_TAG $BUILD_PROJECT/$APP_IMAGESTREAM:$DEPLOYMENT_TAG
  else
    echo "SKIPPED! Since option -d (dry-run) is set."
  fi
}

function promoteToProd {
  echo "Tagging $PROMOTION_PROJECT/$APP_IMAGESTREAM:$PROMOTION_TAG -->  $BUILD_PROJECT/$APP_IMAGESTREAM:$DEPLOYMENT_TAG"
  if [ -z "$dryRun" ]; then
    ocCom tag $BUILD_PROJECT/$APP_IMAGESTREAM:$DEPLOYMENT_TAG $PROMOTION_PROJECT/$APP_IMAGESTREAM:$PROMOTION_TAG
  else
    echo "SKIPPED! Since option -d (dry-run) is set."
  fi
}

function dlTestMasterKey {
  masterKeyFilename=$1
  if [ -z "$masterKeyFilename" ]; then
	masterKeyFilename=.secret
  fi
  echo "Downloading test master-key to $masterKeyFilename . Remember to add this file to .gitignore !"
  oc get secret master-key -n $DEPLOYMENT_PROJECT -o=jsonpath="{.data.master-key}" | base64 --decode > $masterKeyFilename
}



function importProd {
  if [ -z "$dryRun" ]; then
      if [ -z "$OPENSHIFT_USER" ]; then
        echo "HINT: Set environment variable OPENSHIFT_USER with correct username to simplify login"
        echo
        echo "Enter username"
        read u
      else
        echo "Username is $OPENSHIFT_USER"
        u=$OPENSHIFT_USER
      fi
      echo "Enter password for $OPENSHIFT_USER"
      read -s p

      oc logout

      # Get test token
      getOCPHost "test" "ocp_host_test"
      oc login -u "$u" -p "$p" https://$ocp_host_test:8443 > /dev/null
      if [ $? != 0 ]; then
          echo "Failed to log into \"$ocp_host_test\". ABORTING!"
          exit -1
      fi
      ocp_token_test=`oc whoami -t`

      #Get prod token
      getOCPHost "prod" "ocp_host_prod"
      oc login -u "$u" -p "$p" https://$ocp_host_prod:8443 > /dev/null
            if [ $? != 0 ]; then
          echo "Failed to log into \"$ocp_host_prod\". ABORTING!"
          exit -1
      fi
      ocp_token_prod=`oc whoami -t`

      echo "Copying image, please wait...."
      curl -X POST --no-buffer -H "ocp_token_test:$ocp_token_test" -H "ocp_token_prod: $ocp_token_prod"  -H "Content-Type: application/json" "$API/scripts/importProd?test_namespace=$DEPLOYMENT_PROJECT-prod-ready&prod_namespace=$DEPLOYMENT_PROJECT&imageName=$APP_IMAGESTREAM"
      retstatus=$?
      if [ $retstatus == 28 ]; then
        echo "Timed out while waiting for response of copy-job."
        echo "Please wait for a moment,"
        echo "and then use 'occ ver' (in both test and prod) to verify that the image hashes in prod-ready and prod becomes the same."
        echo
        echo "You can also wait for a few minutes, and then repeat 'occ importProd'."
        echo "If the first attempt succeeded, the second will be much faster.."
        exit -1
      fi

  else
    echo "SKIPPED! Since option -d (dry-run) is set."
  fi
}


function showImageVersions {
  if [ x"$ENV" == x"test" ]; then
      if [ -z "$APP_NAME" ]; then
        echo "application.name is missing in spec"
        exit -1;
      fi
      if [[ (! -z "$BUILD_PROJECT") && (! -z "$BUILD_TAG") ]]; then
        echo "Latest build version:"
        echo "---------------------"
        oc get istag $APP_IMAGESTREAM:$BUILD_TAG -n $BUILD_PROJECT
        echo
      fi

      if [[ (! -z "$BUILD_PROJECT") && (! -z "$DEPLOYMENT_TAG") ]]; then
        echo "Latest deployment version:"
        echo "--------------------------"
        oc get istag $APP_IMAGESTREAM:$DEPLOYMENT_TAG -n $BUILD_PROJECT
        echo
      fi

      if [[ (! -z "$PROMOTION_PROJECT") && (! -z "$PROMOTION_TAG") ]]; then
        echo "Version promoted to prod:"
        echo "-------------------------"
        oc get istag $APP_IMAGESTREAM:$PROMOTION_TAG -n $PROMOTION_PROJECT
        echo
      fi
  elif [ x"$ENV" == x"prod" ]; then
    if [[ (! -z "$BUILD_PROJECT") && (! -z "$DEPLOYMENT_TAG") ]]; then
      echo "Latest deployment version:"
      echo "--------------------------"
      oc get istag $APP_IMAGESTREAM:$DEPLOYMENT_TAG -n $BUILD_PROJECT
      echo
    fi
  else
    echo "Unknown environment: $ENV"
  fi
}

function encrypt {
  PLAINTEXT=$1
  curl -s -X POST -H "Accepts: text/plain" -H "Content-Type: text/plain" -H "ocp_token: $OCP_TOKEN" "$API/scripts/$ENV/$DEPLOYMENT_PROJECT/encrypted" -d "$PLAINTEXT"
  echo
}

function printDoc {
  local elementpath=$1
  local full=""
  if [ x"$verbose" == x"y" ]; then
    full='&full=true'
  fi
  echo "DOC for $elementpath:"
  echo "---------------------------------------------"
  curl  -w "\n" -X GET -G -H "Accepts: text/plain" "$API/scripts/specModelDoc/" -d "elementPath=$elementpath$full"
}

function printUsage {
  echo "Usage:"
  echo " occ [OPTIONS] specInfo            # Shows some overall info about the spec"
  echo " occ [OPTIONS] showSpec            # Shows the enriched spec"
  echo " occ [OPTIONS] trimSpec            # Shows the trimmed spec ,removes redundant (inherited) information"
  echo " occ [OPTIONS] ver                 # Show image versions"
  echo " occ [OPTIONS] doc [spec-element]  # Show documentation of spec element. Example: 'occ -v doc application.deployment.namespace'"
  [[ x"$ENV" == x"test" ]] && echo " occ [OPTIONS] bld                 # (re)Installs BUILD-configurations and imagestreams"
  echo " occ [OPTIONS] depl                # (re)Installs DEPLOYMENT-configurations, services, routes and autoscaler"
  [[ x"$HAS_CONFIGMAPS" == x"y" ]] && echo " occ [OPTIONS] cmaps               # (re)Installs CONFIGMAPS"
  [[ x"$ENV" == x"test" && (x"$BUILD_TAG" != x"$DEPLOYMENT_TAG") ]] && echo " occ [OPTIONS] bld2depl            # Deploys latest build           ($BUILD_PROJECT/$APP_IMAGESTREAM:$DEPLOYMENT_TAG --> $BUILD_PROJECT/$APP_IMAGESTREAM:$BUILD_TAG)"
  [[ x"$ENV" == x"test" && (! -z "$PROMOTION_PROJECT") && (! -z "$PROMOTION_TAG") ]] && echo " occ [OPTIONS] promote             # Promotes deployed version      ($PROMOTION_PROJECT/$APP_IMAGESTREAM:$PROMOTION_TAG --> $BUILD_PROJECT/$APP_IMAGESTREAM:$DEPLOYMENT_TAG)"
  [[ x"$ENV" == x"prod" ]] && echo " occ [OPTIONS] importProd          # Imports prod-version to prod env"
  [[ x"$ENV" == x"test" ]] && echo " occ start-build                   # Start build using installed BUILD-configuration"
  [[ x"$ENV" == x"test" ]] && echo " occ dlTestMasterKey [FILENAME]    # Download master-key for test (don't commit it to stash!)"
  echo " occ encrypt <plaintext>           # Encrypts plaintext using master-key secret in deployment namespace"
  echo
  echo "Options:"
  echo "-d        # Dry-run (no changes are made)"
  echo "-v        # Verbose, show interactions with openshift"
  echo "-n        # Do not log out after prod operation. Beware!"
  echo

  SPECDOC=`echo $API | sed -e "s/api$/specdoc/g"`
  echo "For spec documentation and generation of example spec, go to $SPECDOC"
}

function bldInit {

  reloginIfNeccessary

  echo "Setting up CI pipeline"

  export OCP_TOKEN=$(oc whoami -t)

  spec_validation_response=$(curl https://occam-ci.test-dc.corp.telenor.no/api/v1/ci/spec/validation \
      -X POST \
      -H "Content-Type: application/json" \
      -d "$SPEC" \
      --silent \
  )
  if [[ ${spec_validation_response} == *"| ERROR |"* ]]; then
    >&2 echo "$spec_validation_response"
    exit 1
  fi

  echo "Installing imagestream(s)"
  generateOpenshiftObject is
  updateObjects "$API/ocpobject/$ENV/imagestreams/" "is.json"



  if [ -z "$OPENSHIFT_USER" ]; then
     echo "Specify Bitbucket (crowd) username and password to set up CI pipeline"
     read -p "Username (ident): " USERNAME
  else
     echo "Bitbucket username is $OPENSHIFT_USER"
     USERNAME=$OPENSHIFT_USER
  fi

  read -sp "Password: " PASSWORD
  SCM_CREDENTIALS=$(echo -n "$USERNAME:$PASSWORD" | base64)
  GIT_URL=$(git config --get remote.origin.url)
  curl https://occam-ci.test-dc.corp.telenor.no/api/v1/scm/ci \
          -X POST \
          -H "Scm-Credentials: $SCM_CREDENTIALS" \
          -H "Content-Type: application/json" \
          -H "Spec-Path: $(git ls-files --full-name spec.json)" \
          -d "$SPEC"
  exit 0
}

######################### End of functions #########################




# Set api url
API=http://dchub-occam.dc.corp.telenor.no/dchub/occam/api
checkOccamVersion
verifyEnvAgainsOccamEnv


# Parse options
while getopts "d v n" opt; do
  case $opt in
        d)
            dryRun="y" >&2
            ;;
        v)
            verbose="y" >&2
            ;;
        n)
            nologout="y" >&2
            ;;
        :)
          echo "Option -$OPTARG requires an argument." >&2
          exit 1
          ;;
  esac
done
shift $((OPTIND -1))

# Determine environment
getEnv "ENV"

# Determine OCP host
getOCPHost $ENV "OCP_HOST"

# Enrich the spec
SPEC=`curl -s -X POST --header 'Content-Type: application/json' --header "Occam-Git-Url: $(git config --get remote.origin.url)" "$API/spec/enriched" -d "\`cat spec.json\`"`

# Get spec info
eval "`curl -s -X POST --header 'Accept: text/plain' --header 'Content-Type: application/json' "$API/scripts/spec-info" -d "$SPEC"`"

validateSpec

if [[ "$@" == "bld init" ]]; then
    bldInit
fi

if [[ "x$2" != "x" && x"$1" != x"doc" && x"$1" != x"encrypt" && x"$1" != x"dlTestMasterKey" ]]; then
  echo "Invalid command"
  printUsage;
  exit -1;
fi

if [ "x$1" == x"help" ] || [ -z "$1" ]; then
  printUsage;
  exit 0;
elif [[ "x$1" == x"specInfo" ]]; then
  echo "`curl -s -X POST --header 'Accept: text/plain' --header 'Content-Type: application/json' "$API/scripts/spec-info" -d "$SPEC"`" | sed -e "s/export //g"
  exit 0;
elif [[ "x$1" == x"showSpec" ]]; then
  echo "$SPEC"
  exit 0;
elif [[ "x$1" == x"trimSpec" ]]; then
  curl -s -X POST --header 'Content-Type: application/json' "$API/spec/trimmed" -d "$SPEC"
  exit 0;
elif [[ "x$1" == x"importProd" && x"$ENV" == x"prod" ]]; then
  importProd
  exit 0;
elif [[ "x$1" == x"doc" && -n $2 ]]; then
  printDoc $2
  exit 0;
fi

echo "** Environment is $ENV, OCP_HOST is $OCP_HOST"
reloginIfNeccessary
export OCP_TOKEN=`oc whoami -t`

if [[ "x$1" == x"ver" ]]; then
  showImageVersions
elif [[ x"$1" == x"bld" && x"$ENV" == x"test" ]]; then
  reinstallBuild
elif [[ x"$1" == x"start-build" && x"$ENV" == x"test" ]]; then
  startBuild
elif [[ "x$1" == x"depl" ]]; then
  reinstallDeployment
elif [[ x"$1" == x"cmaps" && x"$HAS_CONFIGMAPS" == x"y" ]]; then
  reinstallConfigMaps
elif [[ "x$1" == x"bld2depl" && x"$ENV" == x"test" ]]; then
  promoteToTest
elif [[ "x$1" == x"promote" && x"$ENV" == x"test" ]]; then
  promoteToProd
elif [[ "x$1" == x"dlTestMasterKey" && x"$ENV" == x"test" ]]; then
  dlTestMasterKey $2
elif [ "x$1" == x"encrypt" ]; then
  encrypt $2
else
  echo "Invalid command!"
  printUsage;
  exit;
fi

if [[ x"$ENV" == x"prod" ]]; then

    if [[ x"$nologout" != x"y" ]]; then
        oc logout
    else
        echo "*** NOT LOGGED OUT FROM PROD! Do not use option '-n' unless really required to do so.. ***"
    fi
fi
